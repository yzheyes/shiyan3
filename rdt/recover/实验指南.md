# RDT（可靠数据传输）协议实验指南

## 一、实验目的

熟悉并掌握各种不同RDT协议的运行环境和协议性能，通过模拟实验深入理解可靠数据传输协议的工作原理和性能特征。

## 二、实验环境准备

### 2.1 系统要求

- **操作系统**：Linux平台（推荐使用Red Hat Linux 8.0或9.0，2.4内核）
- **编译器**：支持C语言编译（如gcc或cc）
- **开发工具**：make工具

### 2.2 环境搭建

#### 步骤1：准备Linux环境
如果当前系统不是Linux，可以：
- 安装虚拟机软件（如VirtualBox、VMware）
- 在虚拟机中安装Linux系统
- 或者使用WSL（Windows Subsystem for Linux）

#### 步骤2：复制模拟器文件
将`simulator_new`目录下的所有文件复制到操作系统的相应工作目录中：

```bash
cp -r rdt/simulator_new ~/rdt_lab/
cd ~/rdt_lab
```

#### 步骤3：编译模拟器
查看Makefile文件，确认编译器设置：

```bash
# 查看Makefile内容
cat Makefile
```

如果需要使用gcc编译器，确保Makefile中包含：
```makefile
CC=gcc
```

编译模拟器：
```bash
make clean
make
```

编译成功后会生成`sim`可执行文件。

## 三、模拟器使用说明

### 3.1 命令行参数格式

```bash
./sim protocol events timeout pct_loss pct_cksum debug_flags
```

**参数说明：**

| 参数 | 说明 | 取值范围 |
|------|------|----------|
| protocol | 协议编号 | 2-6 |
| events | 模拟运行的事件数 | 正整数 |
| timeout | 超时间隔（以tick为单位） | 正整数 |
| pct_loss | 丢包率（百分比） | 0-99 |
| pct_cksum | 校验和错误率（百分比） | 0-99 |
| debug_flags | 调试标志 | 位掩码 |

### 3.2 调试标志（debug_flags）

调试标志使用位掩码方式设置，可以组合使用：

| 值 | 含义 |
|----|------|
| 1 | 显示发送的帧 |
| 2 | 显示接收的帧 |
| 4 | 显示超时事件 |
| 8 | 定期打印统计信息（用于长时间运行） |

**示例：**
- `debug_flags=1`：只显示发送的帧
- `debug_flags=3`：显示发送和接收的帧（1+2）
- `debug_flags=7`：显示发送、接收和超时事件（1+2+4）

### 3.3 运行示例

#### 示例1：运行协议6
```bash
./sim 6 100000 40 20 10 3
```

**解释：**
- 协议6
- 运行100,000个事件
- 超时间隔为40 ticks
- 丢包率为20%
- 校验和错误率为10%
- 显示发送和接收的帧（debug_flags=3）

#### 示例2：运行协议5，仅显示统计信息
```bash
./sim 5 50000 50 10 5 0
```

#### 示例3：运行协议5，显示所有调试信息
```bash
./sim 5 50000 50 10 5 7
```

### 3.4 输出结果说明

模拟器运行结束后会输出以下统计信息：

```
Process 0:
	Total data frames sent:       1234
	Data frames lost:              123
	Data frames not lost:         1111
	Frames retransmitted:         456
	Good ack frames rec'd:         987
	Bad ack frames rec'd:           12

	Good data frames rec'd:        987
	Bad data frames rec'd:          12
	Payloads accepted:             987
	Total ack frames sent:        1099
	Ack frames lost:               109
	Ack frames not lost:           990

	Timeouts:                      234
	Ack timeouts:                   12

Efficiency (payloads accepted/data pkts sent) = 80%
End of simulation.  Time=50000
```

**关键指标解释：**
- **Efficiency**：效率 = (有效载荷接受数 / 发送的数据包数) × 100%
- **Payloads accepted**：成功传递给网络层的有效载荷数量
- **Frames retransmitted**：重传的帧数量
- **Timeouts**：超时事件数量

## 四、协议说明

### 4.1 协议2（简单停止等待协议）

**特点：**
- 最简单的可靠数据传输协议
- 每次发送一个数据帧后等待确认
- 不支持流水线传输

**适用场景：**
- 低延迟网络
- 理解基本可靠传输原理

### 4.2 协议3（带校验和的停止等待）

**特点：**
- 在协议2基础上增加校验和错误处理
- 检测损坏的帧
- 仍然采用停止等待机制

### 4.3 协议4（带序号的停止等待）

**特点：**
- 增加帧序号机制
- 防止重复帧
- 仍然是停止等待方式

### 4.4 协议5（回退N帧协议）

**特点：**
- 支持流水线传输
- 发送方可以发送多个未确认的帧（最多MAX_SEQ=7个）
- 超时后重传所有未确认的帧
- 采用累积确认机制

**关键参数：**
- `MAX_SEQ = 7`：最大序列号（2^n - 1）
- 滑动窗口大小：最多7个未确认帧

**代码结构：**
```c
void protocol5(void) {
    seq_nr next_frame_to_send;  // 下一个要发送的帧序号
    seq_nr ack_expected;        // 最早未确认的帧序号
    seq_nr frame_expected;      // 期望接收的帧序号
    packet buffer[MAX_SEQ+1];   // 发送缓冲区
    seq_nr nbuffered;           // 已缓冲的帧数量
    ...
}
```

**超时处理：**
```c
case timeout:
    next_frame_to_send = ack_expected;  // 从最早未确认帧开始重传
    for (i = 1; i <= nbuffered; i++) {
        send_data(next_frame_to_send, frame_expected, buffer);
        inc(next_frame_to_send);
    }
```

### 4.5 协议6（选择性重传协议）

**特点：**
- 支持乱序接收
- 接收方可以缓存乱序到达的帧
- 超时后只重传超时的单个帧
- 支持NAK（否定确认）机制
- 独立的ACK定时器

**关键参数：**
- `MAX_SEQ = 7`：最大序列号
- `NR_BUFS = 4`：发送和接收缓冲区数量

**代码结构：**
```c
void protocol6(void) {
    packet out_buf[NR_BUFS];   // 发送缓冲区
    packet in_buf[NR_BUFS];    // 接收缓冲区
    boolean arrived[NR_BUFS];  // 接收状态位图
    seq_nr frame_expected;    // 期望接收的帧序号
    seq_nr too_far;            // 接收窗口上界
    ...
}
```

**超时处理：**
```c
case timeout:
    send_frame(data, oldest_frame, frame_expected, out_buf);
    // 只重传超时的单个帧
```

## 五、实验作业详解

### 作业1：协议性能研究

**任务：**
对于一个或多个选定的协议，研究协议性能（以每秒传递的有效载荷数量来衡量）作为校验和错误率、丢包率和超时间隔的函数。

**实验步骤：**

1. **选择协议**：建议选择协议5和协议6进行对比

2. **设计实验参数**：

   a) 固定其他参数，改变超时间隔：
   ```bash
   # 协议5，不同超时间隔
   ./sim 5 50000 20 10 5 0 > p5_timeout_20.txt
   ./sim 5 50000 30 10 5 0 > p5_timeout_30.txt
   ./sim 5 50000 40 10 5 0 > p5_timeout_40.txt
   ./sim 5 50000 50 10 5 0 > p5_timeout_50.txt
   ./sim 5 50000 60 10 5 0 > p5_timeout_60.txt
   ./sim 5 50000 80 10 5 0 > p5_timeout_80.txt
   ./sim 5 50000 100 10 5 0 > p5_timeout_100.txt
   ```

   b) 固定其他参数，改变丢包率：
   ```bash
   # 协议5，不同丢包率
   ./sim 5 50000 50 0 5 0 > p5_loss_0.txt
   ./sim 5 50000 50 5 5 0 > p5_loss_5.txt
   ./sim 5 50000 50 10 5 0 > p5_loss_10.txt
   ./sim 5 50000 50 20 5 0 > p5_loss_20.txt
   ./sim 5 50000 50 30 5 0 > p5_loss_30.txt
   ```

   c) 固定其他参数，改变校验和错误率：
   ```bash
   # 协议5，不同校验和错误率
   ./sim 5 50000 50 10 0 0 > p5_cksum_0.txt
   ./sim 5 50000 50 10 5 0 > p5_cksum_5.txt
   ./sim 5 50000 50 10 10 0 > p5_cksum_10.txt
   ./sim 5 50000 50 10 15 0 > p5_cksum_15.txt
   ./sim 5 50000 50 10 20 0 > p5_cksum_20.txt
   ```

3. **提取效率数据**：
   从输出文件中提取Efficiency值：
   ```bash
   grep "Efficiency" p5_timeout_*.txt
   ```

4. **绘制图表**：
   使用工具（如gnuplot、Python matplotlib、Excel等）绘制：
   - 效率 vs 超时间隔（针对不同错误率）
   - 效率 vs 丢包率
   - 效率 vs 校验和错误率

**预期结论：**
- 超时间隔过短会导致频繁超时，降低效率
- 超时间隔过长会增加等待时间，也会降低效率
- 存在一个最优的超时间隔
- 丢包率和校验和错误率越高，效率越低

### 作业2：协议5与协议6性能对比

**任务：**
详细比较协议5和协议6在各种参数下的性能，包括每秒有效载荷数量和重传次数。

**实验步骤：**

1. **设计对比实验**：

   ```bash
   # 不同丢包率下的对比
   for loss in 0 5 10 15 20 25 30; do
       ./sim 5 50000 50 $loss 5 0 > p5_loss_$loss.txt
       ./sim 6 50000 50 $loss 5 0 > p6_loss_$loss.txt
   done

   # 不同超时间隔下的对比
   for timeout in 20 30 40 50 60 80 100; do
       ./sim 5 50000 $timeout 10 5 0 > p5_timeout_$timeout.txt
       ./sim 6 50000 $timeout 10 5 0 > p6_timeout_$timeout.txt
   done

   # 不同校验和错误率下的对比
   for cksum in 0 5 10 15 20 25; do
       ./sim 5 50000 50 10 $cksum 0 > p5_cksum_$cksum.txt
       ./sim 6 50000 50 10 $cksum 0 > p6_cksum_$cksum.txt
   done
   ```

2. **提取关键数据**：
   - Efficiency（效率）
   - Frames retransmitted（重传帧数）
   - Timeouts（超时次数）

3. **数据整理表**：

   | 丢包率 | P5效率 | P6效率 | P5重传 | P6重传 | P5超时 | P6超时 |
   |--------|--------|--------|--------|--------|--------|--------|
   | 0%     |        |        |        |        |        |        |
   | 5%     |        |        |        |        |        |        |
   | 10%    |        |        |        |        |        |        |
   | ...    |        |        |        |        |        |        |

4. **绘制对比图表**：
   - 效率对比曲线
   - 重传次数对比柱状图

**预期结论：**

**协议5更好的情况：**
- 低错误率环境
- 丢包率较低时
- 网络延迟较稳定时
- 实现简单，开销小

**协议6更好的情况：**
- 高错误率环境
- 丢包率较高时
- 网络延迟变化较大时
- 需要更高吞吐量时
- 带宽利用率要求高时

**原因分析：**
- 协议5超时后重传所有未确认帧，在高错误率下会浪费带宽
- 协议6只重传超时的单个帧，带宽利用率更高
- 协议6需要维护接收缓冲区和状态，实现更复杂

### 作业3：事件优先级研究

**任务：**
函数pick_event()内置了事件的优先级。例如，对于协议5，帧到达优先于超时。尝试通过重新排列pick_event()中的语句来改变这些优先级。

**实验步骤：**

1. **查看原始pick_event()函数**：
   在`worker.c`文件的第187-262行，协议5的事件选择逻辑为：

   ```c
   case 5:  // {frame_arrival, cksum_err, timeout, network_layer_ready}
       if (nframes > 0) return((int)frametype());           // 优先级1：帧到达
       if (network_layer_status) return(network_layer_ready); // 优先级2：网络层就绪
       if (check_timers() >= 0) return(timeout);            // 优先级3：超时
       return(NO_EVENT);
   ```

   **原始优先级顺序：**
   1. 帧到达（frame_arrival/cksum_err）
   2. 网络层就绪（network_layer_ready）
   3. 超时（timeout）

2. **修改优先级**：
   编辑`worker.c`文件，修改协议5的事件优先级。

   **修改方案A：超时优先**
   ```c
   case 5:
       if (check_timers() >= 0) return(timeout);            // 优先级1：超时
       if (nframes > 0) return((int)frametype());           // 优先级2：帧到达
       if (network_layer_status) return(network_layer_ready); // 优先级3：网络层就绪
       return(NO_EVENT);
   ```

   **修改方案B：网络层就绪优先**
   ```c
   case 5:
       if (network_layer_status) return(network_layer_ready); // 优先级1：网络层就绪
       if (nframes > 0) return((int)frametype());           // 优先级2：帧到达
       if (check_timers() >= 0) return(timeout);            // 优先级3：超时
       return(NO_EVENT);
   ```

3. **重新编译**：
   ```bash
   make clean
   make
   ```

4. **对比测试**：
   ```bash
   # 原始优先级
   ./sim 5 50000 50 10 5 0 > original.txt

   # 修改后（超时优先）
   ./sim 5 50000 50 10 5 0 > timeout_first.txt

   # 修改后（网络层就绪优先）
   ./sim 5 50000 50 10 5 0 > net_first.txt
   ```

5. **分析结果**：
   比较不同优先级下的：
   - 效率
   - 超时次数
   - 重传次数

**预期结论：**
- 原始优先级（帧到达优先）是最合理的
- 帧到达优先可以更快处理确认，减少不必要的重传
- 超时优先可能导致更多的重传
- 网络层就绪优先可能导致发送方过度发送，增加拥塞

### 作业4：重传帧数量研究

**任务：**
调查重传帧的数量作为超时间隔的函数，针对各种参数。确定最佳设置应该是什么。

**实验步骤：**

1. **设计实验参数矩阵**：

   创建不同超时间隔和错误率的组合：

   ```bash
   # 协议5
   for timeout in 20 30 40 50 60 80 100 120 150; do
       for loss in 0 5 10 15 20 25; do
           ./sim 5 50000 $timeout $loss 5 0 > p5_t${timeout}_l${loss}.txt
       done
   done

   # 协议6
   for timeout in 20 30 40 50 60 80 100 120 150; do
       for loss in 0 5 10 15 20 25; do
           ./sim 6 50000 $timeout $loss 5 0 > p6_t${timeout}_l${loss}.txt
       done
   done
   ```

2. **提取重传数据**：
   ```bash
   grep "Frames retransmitted" p5_*.txt
   grep "Timeouts" p5_*.txt
   ```

3. **数据整理**：

   | 超时间隔 | 丢包率0% | 丢包率5% | 丢包率10% | 丢包率15% | 丢包率20% | 丢包率25% |
   |----------|---------|---------|----------|----------|----------|----------|
   | 20       |         |         |          |          |          |          |
   | 30       |         |         |          |          |          |          |
   | 40       |         |         |          |          |          |          |
   | ...      |         |         |          |          |          |          |

4. **绘制图表**：
   - 重传次数 vs 超时间隔（针对不同丢包率）
   - 效率 vs 超时间隔

5. **确定最佳超时间隔**：
   - 找出每个丢包率下效率最高的超时间隔
   - 绘制最佳超时间隔 vs 丢包率的曲线

**预期结论：**
- 超时间隔应该根据网络条件动态调整
- 在高丢包率环境下，需要更长的超时间隔
- 存在一个权衡点：太短导致频繁超时，太长导致响应慢
- 最佳超时间隔 ≈ 往返时间 × 安全系数（通常2-4倍）

### 作业5：模拟器时间推进优化

**任务：**
目前，模拟器每次前进一个时间单位。如果两个进程都在等待遥远的超时，这个过程会很慢。修改模拟器，使其在两个进程都在等待时钟时能够更快地推进时间。

**实验步骤：**

1. **分析当前时间推进机制**：
   查看`sim.c`文件第74-89行的主循环：

   ```c
   while (tick < last_tick) {
       process = rand() & 1;          // 随机选择进程
       tick = tick + DELTA;           // 每次前进DELTA个tick
       rfd = (process == 0 ? r4 : r6);
       if (read(rfd, &word, TICK_SIZE) != TICK_SIZE) terminate("");
       if (word == OK) hanging[process] = 0;
       if (word == NOTHING) hanging[process] += DELTA;
       ...
   }
   ```

   当前问题：
   - 每次只前进DELTA（10）个tick
   - 当两个进程都在等待超时时，会浪费大量时间

2. **优化方案**：
   修改`sim.c`的主循环，检测两个进程都在等待超时的情况，直接跳到下一个事件时间。

   **修改代码示例：**

   ```c
   // 在sim.c中添加新的时间推进逻辑
   while (tick < last_tick) {
       process = rand() & 1;
       
       // 检查两个进程是否都在等待超时
       if (hanging[0] >= DEADLOCK/2 && hanging[1] >= DEADLOCK/2) {
           // 两个进程都在等待，直接跳到下一个超时时间
           // 这里需要从worker进程获取下一个超时时间
           // 简化方案：跳过多个DELTA
           tick = tick + DELTA * 10;  // 跳过10倍的时间
       } else {
           tick = tick + DELTA;
       }
       
       rfd = (process == 0 ? r4 : r6);
       if (read(rfd, &word, TICK_SIZE) != TICK_SIZE) terminate("");
       ...
   }
   ```

3. **更完整的优化方案**：
   需要在worker.c中添加函数来报告下一个超时时间，然后在主循环中使用这个信息。

   **步骤：**
   a) 在worker.c中添加函数：
   ```c
   bigint get_next_timeout(void) {
       if (lowest_timer > 0) {
           return lowest_timer;
       }
       if (aux_timer > 0) {
           return aux_timer;
       }
       return 0;
   }
   ```

   b) 修改worker与main的通信机制，传递下一个超时时间

   c) 修改sim.c主循环，使用超时信息快速推进时间

4. **测试优化效果**：
   ```bash
   # 测试长时间运行的模拟
   time ./sim 5 1000000 100 10 5 0
   ```

   比较优化前后的运行时间。

**预期结论：**
- 优化后可以显著减少空闲等待时间
- 对于长超时间隔的模拟，加速效果更明显
- 不影响模拟结果的正确性

### 作业6：可变数据包传递时间

**任务：**
在当前的模拟器中，数据包传递本质上是即时的。将其更改为传递时间可变，并且方差可以由用户设置。方差如何影响协议性能？

**实验步骤：**

1. **分析当前传递机制**：
   查看`worker.c`中的`to_physical_layer()`函数（第352-434行）。

   当前机制：
   - 帧通过管道直接传递
   - 传递是即时的（在同一个tick内）

2. **设计可变延迟机制**：

   **方案A：延迟队列**
   - 为每个发送的帧添加延迟时间
   - 使用延迟队列存储待传递的帧
   - 在每个tick检查是否有帧到期

   **方案B：随机延迟**
   - 为每个帧生成随机延迟
   - 延迟 = 基础延迟 + 随机变化

3. **实现步骤**：

   a) 在`common.h`中添加新参数：
   ```c
   extern int base_delay;      // 基础延迟
   extern int delay_variance;   // 延迟方差
   ```

   b) 在`sim.c`中解析新参数：
   ```c
   // 修改parse_args函数，添加延迟参数
   base_delay = atoi(argv[7]);
   delay_variance = atoi(argv[8]);
   ```

   c) 在`worker.c`中实现延迟传递：
   ```c
   typedef struct {
       frame f;
       bigint delivery_time;
   } delayed_frame;

   delayed_frame delay_queue[MAX_QUEUE];
   int n_delayed = 0;

   void to_physical_layer(frame *s) {
       // 计算延迟时间
       int variance = (rand() % (2 * delay_variance + 1)) - delay_variance;
       bigint delay = base_delay + variance;
       if (delay < 0) delay = 0;

       // 添加到延迟队列
       delay_queue[n_delayed].f = *s;
       delay_queue[n_delayed].delivery_time = tick + delay;
       n_delayed++;
   }

   void process_delayed_frames(void) {
       // 检查是否有帧到期
       for (int i = 0; i < n_delayed; i++) {
           if (tick >= delay_queue[i].delivery_time) {
               // 实际发送帧
               int fd = (id == 0 ? w1 : w2);
               write(fd, &delay_queue[i].f, FRAME_SIZE);
               // 从队列中移除
               delay_queue[i] = delay_queue[n_delayed - 1];
               n_delayed--;
               i--;
           }
       }
   }
   ```

   d) 在主循环中调用延迟处理：
   ```c
   // 在wait_for_event中添加
   process_delayed_frames();
   ```

4. **编译测试**：
   ```bash
   make clean
   make
   ```

5. **实验测试**：

   ```bash
   # 不同延迟方差下的测试
   ./sim 5 50000 50 10 5 0 10 0 > delay_var_0.txt    # 无方差
   ./sim 5 50000 50 10 5 0 10 5 > delay_var_5.txt    # 方差5
   ./sim 5 50000 50 10 5 0 10 10 > delay_var_10.txt  # 方差10
   ./sim 5 50000 50 10 5 0 10 20 > delay_var_20.txt  # 方差20
   ```

6. **分析结果**：
   比较不同延迟方差下的：
   - 效率
   - 超时次数
   - 重传次数

**预期结论：**
- 延迟方差越大，协议性能越差
- 高延迟方差会导致更多的超时和重传
- 协议6对延迟方差的容忍度可能比协议5更好
- 需要更长的超时间隔来应对高方差环境

## 六、实验报告撰写指南

### 6.1 报告结构

1. **实验目的**
2. **实验环境**
3. **实验原理**
4. **实验步骤**
5. **实验结果**
6. **结果分析**
7. **结论与讨论**
8. **参考文献**

### 6.2 内容要求

**实验目的**：
- 清晰说明实验目标
- 列出要完成的任务

**实验环境**：
- 硬件配置
- 软件环境（操作系统、编译器版本等）
- 模拟器配置

**实验原理**：
- 简要介绍RDT协议的基本原理
- 说明各协议的特点和区别
- 解释关键概念（滑动窗口、超时重传等）

**实验步骤**：
- 详细描述实验过程
- 列出使用的命令和参数
- 说明数据收集方法

**实验结果**：
- 使用表格整理数据
- 绘制清晰的图表
- 标注图表的坐标轴和图例

**结果分析**：
- 解释数据趋势
- 分析不同参数对性能的影响
- 对比不同协议的优缺点

**结论与讨论**：
- 总结实验发现
- 提出协议选择的建议
- 讨论实验的局限性
- 提出可能的改进方向

### 6.3 图表制作建议

**推荐工具：**
- Python + matplotlib
- gnuplot
- Excel/LibreOffice Calc
- R语言

**图表类型：**
- 折线图：展示趋势变化
- 柱状图：对比不同条件
- 散点图：展示相关性

**图表要求：**
- 清晰的标题
- 标注坐标轴
- 使用图例
- 合理的刻度范围

## 七、常见问题与解决方案

### 7.1 编译问题

**问题1：make命令失败**
```bash
make: cc: Command not found
```
**解决**：安装编译器
```bash
# Ubuntu/Debian
sudo apt-get install build-essential

# Red Hat/CentOS
sudo yum groupinstall "Development Tools"
```

**问题2：链接错误**
```bash
undefined reference to 'function_name'
```
**解决**：检查Makefile，确保所有源文件都被编译

### 7.2 运行问题

**问题1：参数错误**
```bash
Usage: sim protocol events timeout loss cksum debug
```
**解决**：检查参数数量和格式，确保有6个参数

**问题2：死锁检测**
```bash
A deadlock has been detected
```
**解决**：
- 检查超时间隔是否过短
- 增加超时间隔
- 检查丢包率是否过高

### 7.3 性能问题

**问题1：模拟运行很慢**
**解决**：
- 减少事件数量
- 使用优化后的模拟器（作业5）
- 使用较低的debug_flags

**问题2：内存不足**
```bash
Out of queue space. Increase MAX_QUEUE and re-make.
```
**解决**：
- 在worker.c中增加MAX_QUEUE的值
- 重新编译

## 八、附录

### 8.1 模拟器文件说明

| 文件 | 说明 |
|------|------|
| sim.c | 主程序，负责进程管理和时间推进 |
| worker.c | 工作进程，实现协议逻辑和事件处理 |
| protocol.h | 协议相关的数据结构和函数声明 |
| common.h | 公共数据结构和全局变量 |
| p2.c-p6.c | 各个协议的实现 |
| Makefile | 编译配置文件 |
| README | 使用说明 |

### 8.2 关键数据结构

**帧结构（frame）**：
```c
typedef struct {
    frame_kind kind;  // 帧类型：data, ack, nak
    seq_nr seq;       // 序列号
    seq_nr ack;       // 确认号
    packet info;      // 载荷数据
} frame;
```

**包结构（packet）**：
```c
typedef struct {
    unsigned char data[MAX_PKT];  // 数据，MAX_PKT=4字节
} packet;
```

**事件类型（event_type）**：
```c
typedef enum {
    frame_arrival,      // 帧到达
    cksum_err,          // 校验和错误
    timeout,            // 超时
    network_layer_ready,// 网络层就绪
    ack_timeout         // ACK超时
} event_type;
```

### 8.3 调试技巧

1. **使用debug_flags**：
   - 从小值开始（1, 2, 4）
   - 逐步增加调试信息
   - 长时间运行使用8查看定期统计

2. **重定向输出**：
   ```bash
   ./sim 5 50000 50 10 5 7 > output.txt 2>&1
   ```

3. **分析日志**：
   - 查找超时模式
   - 分析重传原因
   - 统计丢包和错误

4. **使用grep提取关键信息**：
   ```bash
   grep "Efficiency" output.txt
   grep "Timeouts" output.txt
   grep "retransmitted" output.txt
   ```

### 8.4 参考资源

1. **教材**：
   - Andrew S. Tanenbaum, "Computer Networks, 3rd ed.", Chapter 3

2. **在线资源**：
   - TCP/IP协议详解
   - 可靠数据传输协议原理

3. **工具文档**：
   - gcc编译器文档
   - make工具文档
   - gnuplot绘图教程

---

**实验注意事项：**

1. 实验前仔细阅读README文件
2. 每次修改代码后重新编译
3. 保存实验数据和结果
4. 及时记录实验观察
5. 注意数据备份，避免意外丢失

**祝实验顺利！**
