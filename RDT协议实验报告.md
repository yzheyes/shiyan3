# 可靠数据传输（RDT）协议实验报告

**实验日期：** 2025年12月28日  
**实验环境：** Linux Ubuntu (虚拟机)  
**编译器：** GCC 4.3  

---

## 一、实验目的

1. 熟悉并掌握各种不同RDT协议的运行环境和协议性能
2. 理解Go-Back-N（协议5）和选择性重传（协议6）的工作原理
3. 分析网络参数（超时间隔、丢包率、校验和错误率）对协议性能的影响
4. 比较不同协议在各种网络环境下的性能表现
5. 掌握数据链路层协议的实验方法和性能评估技术

---

## 二、实验环境与工具

### 2.1 硬件环境
- 处理器：x86_64架构
- 内存：充足以运行模拟器
- 操作系统：Linux Ubuntu（虚拟机）

### 2.2 软件环境
- 编译器：GCC 4.3
- 编译选项：`-D_POSIX_SOURCE`
- 模拟器：RDT协议模拟器（Tanenbaum《计算机网络》配套）

### 2.3 实验协议

本模拟器支持协议2-6共5种可靠数据传输协议：
- **协议2（Stop-and-Wait）：** 停等协议，最基础的可靠传输
- **协议3（PAR）：** 带超时重传的停等协议
- **协议4（1-bit Sliding Window）：** 1位滑动窗口，支持双向数据流
- **协议5（Go-Back-N）：** 回退N帧协议，窗口大小MAX_SEQ=7（实验重点）
- **协议6（选择性重传）：** 选择性重传协议，窗口大小MAX_SEQ=7（实验重点）

**本实验聚焦于协议5和协议6**，因为：
1. 协议5、6是最先进的滑动窗口协议
2. 两者性能对比最具研究价值
3. 现代网络协议（如TCP）主要基于这两种机制
4. 协议2-4主要用于教学和简单场景

---

## 三、协议原理讲解

本模拟器实现了Tanenbaum《计算机网络》第3章介绍的5种可靠数据传输协议（协议2-6），展示了从简单到复杂的协议演进过程。

### 3.1 协议演进概述

| 协议编号 | 协议名称 | 关键特征 | 主要改进 |
|---------|---------|---------|---------|
| 协议2 | Stop-and-Wait | 停等机制，无超时 | 基础确认机制 |
| 协议3 | PAR (Positive Acknowledgment with Retransmission) | 停等+超时重传 | 增加超时机制 |
| 协议4 | 1-bit Sliding Window | 1位序号滑动窗口 | 双向数据流 |
| 协议5 | Go-Back-N | N帧发送窗口 | 流水线传输 |
| 协议6 | Selective Repeat | N帧发送+接收窗口 | 选择性重传 |

### 3.2 停等协议（协议2）

#### 工作原理
最简单的可靠传输协议，发送方发送一帧后必须等待接收方的确认（ACK）才能发送下一帧。

**核心特征：**
- 发送窗口大小：1帧
- 接收窗口大小：1帧
- 无超时机制：假设信道完全可靠
- 严格的停等：发送→等待ACK→发送下一帧

**工作流程：**
```
发送方：
1. 从网络层获取数据包
2. 封装成帧并发送
3. 等待ACK确认
4. 收到ACK后发送下一帧

接收方：
1. 等待接收帧
2. 检查帧是否正确（校验和）
3. 正确则递交网络层并发送ACK
4. 错误则丢弃（不发送任何响应）
```

**优点：**
- 实现极其简单
- 逻辑清晰易于理解
- 不需要复杂的缓存管理

**缺点：**
- 无超时机制，帧丢失时会永久等待
- 信道利用率极低（停等造成大量空闲时间）
- 不适用于真实网络环境

**适用场景：**
- 教学演示
- 完全可靠的点对点链路（理论场景）

### 3.3 带重传的停等协议（协议3 - PAR）

#### 工作原理
在协议2基础上增加了超时重传机制，能够应对帧丢失和损坏的情况。

**核心特征：**
- 发送窗口大小：1帧
- 接收窗口大小：1帧
- **增加超时机制**：发送后启动定时器
- **序号**：1位序号（0/1交替）区分新帧和重传帧

**工作流程：**
```
发送方：
1. 发送帧并启动超时定时器
2. 收到ACK：关闭定时器，发送下一帧
3. 超时：重传该帧，重启定时器
4. 使用序号0/1交替，防止重复

接收方：
1. 收到正确的期望帧：递交上层，发送ACK
2. 收到错误帧或重复帧：丢弃，重发上次ACK
3. ACK携带期望接收的序号
```

**改进点：**
- 超时重传机制解决了帧丢失问题
- 序号机制防止重复帧被接受
- 可以在有丢包和错误的真实信道上工作

**缺点：**
- 仍然是停等机制，信道利用率低
- 每帧必须等待ACK，延迟高
- 不适合长距离、高延迟网络

**性能分析：**
- 效率 = 帧长 / (帧长 + 2×传播延迟)
- 在短距离链路上可接受
- 长距离或高延迟链路效率很低

### 3.4 1位滑动窗口协议（协议4）

#### 工作原理
允许双向数据流，利用捎带确认（piggybacking）机制提高效率。

**核心特征：**
- 发送窗口大小：1帧
- 接收窗口大小：1帧
- **双向数据流**：两端都可以发送数据
- **捎带确认**：ACK信息搭载在数据帧中

**工作流程：**
```
双向通信：
1. A发送数据帧（seq=0）给B
2. B收到后，将ACK=1捎带在给A的数据帧中
3. A收到B的数据+ACK，继续发送（seq=1）
4. 减少了独立ACK帧的数量

超时处理：
1. 发送数据帧后启动定时器
2. 收到对方数据帧（携带ACK）：确认成功
3. 超时：重传数据帧
```

**改进点：**
- 捎带确认减少了ACK帧数量
- 支持双向数据流，更实用
- 在交互式应用中效率较高

**缺点：**
- 仍然是1帧窗口，不能流水线传输
- 信道利用率受限于停等机制
- 不适合单向大数据量传输

**适用场景：**
- 交互式应用（如Telnet、SSH）
- 双向数据流较均衡的场景
- 短距离、低延迟网络

### 3.5 Go-Back-N协议（协议5）

#### 工作原理
Go-Back-N协议是一种滑动窗口协议，发送方可以在未收到确认的情况下连续发送多个帧，但接收方只能按序接收帧。

**核心特征：**
- 发送窗口大小：N帧（本实验中N=7）
- 接收窗口大小：1帧
- 累积确认：确认号表示该序号之前的所有帧均已正确接收
- 重传策略：超时后重传所有已发送但未确认的帧

**状态机：**
```
发送方状态：
1. 等待网络层数据
2. 发送帧并启动定时器
3. 接收ACK，滑动窗口
4. 超时，回退重传所有未确认的帧

接收方状态：
1. 等待期望序号的帧
2. 正确收到：递交上层，发送ACK
3. 错误/失序：丢弃帧，重发上次ACK
```

**优点：**
- 实现简单
- 接收方缓存需求小（只需1个帧缓存）
- 累积确认减少ACK数量

**缺点：**
- 出错时需要重传多个帧（即使某些帧已正确接收）
- 信道利用率在高丢包率时显著下降
- 对超时间隔设置敏感

### 3.6 选择性重传协议（协议6）

#### 工作原理
选择性重传协议允许接收方乱序接收帧并缓存，只重传出错或丢失的帧。

**核心特征：**
- 发送窗口大小：N帧（本实验中N=7）
- 接收窗口大小：N帧
- 单独确认：每个帧单独确认
- 重传策略：只重传超时或NAK指示的帧

**状态机：**
```
发送方状态：
1. 等待网络层数据
2. 发送帧并为每帧启动独立定时器
3. 接收ACK，标记该帧已确认
4. 超时，只重传该特定帧

接收方状态：
1. 维护接收窗口
2. 正确收到窗口内的帧：缓存并发送ACK
3. 帧失序但在窗口内：缓存等待前序帧
4. 收齐连续序列：递交上层，滑动窗口
```

**优点：**
- 只重传出错的帧，效率高
- 高丢包率下性能优异
- 对网络条件变化不敏感

**缺点：**
- 实现复杂
- 接收方需要较大缓存（N个帧缓存）
- 每帧独立确认，ACK数量多

### 3.7 协议完整对比

#### 3.7.1 按复杂度递增的演进

```
协议2 (Stop-and-Wait)
   ↓ 增加超时+序号
协议3 (PAR)
   ↓ 增加双向流+捎带
协议4 (1-bit Sliding Window)
   ↓ 增加发送窗口
协议5 (Go-Back-N)
   ↓ 增加接收窗口
协议6 (Selective Repeat)
```

#### 3.7.2 全协议对比表

| 特性 | 协议2 | 协议3 | 协议4 | 协议5 (GBN) | 协议6 (SR) |
|-----|------|------|------|-------------|-----------|
| 发送窗口 | 1 | 1 | 1 | N | N |
| 接收窗口 | 1 | 1 | 1 | 1 | N |
| 超时机制 | ❌ | ✅ | ✅ | ✅ | ✅ |
| 序号位数 | 0 | 1 | 1 | log₂(N+1) | log₂(N+1) |
| 确认方式 | 单独ACK | 单独ACK | 捎带ACK | 累积ACK | 单独ACK |
| 重传策略 | 无 | 超时重传 | 超时重传 | 回退N帧 | 选择重传 |
| 双向数据 | ❌ | ❌ | ✅ | ✅ | ✅ |
| 流水线 | ❌ | ❌ | ❌ | ✅ | ✅ |
| 缓存需求 | 极小 | 极小 | 小 | 小 | 大 |
| 实现复杂度 | 极简 | 简单 | 简单 | 中等 | 复杂 |
| 信道利用率 | 极低 | 极低 | 低 | 高 | 最高 |
| 适用丢包率 | 0% | <5% | <5% | <10% | 任意 |
| 延迟敏感性 | 极高 | 极高 | 高 | 中 | 低 |

#### 3.7.3 效率对比（理论分析）

假设：
- 帧长：L bits
- 带宽：B bps
- 传播延迟：D seconds
- 窗口大小：W帧（协议5、6）

**协议2、3、4效率：**
```
效率 = L / (L + 2BD)
```
示例：L=1000bits, B=1Mbps, D=10ms
效率 = 1000 / (1000 + 2×10⁶×0.01) = 1000/21000 ≈ 4.8%

**协议5、6效率（理想情况，无丢包）：**
```
效率 = min(1, WL / (L + 2BD))
```
窗口W=7时：
效率 = min(1, 7×1000/21000) = min(1, 0.33) = 33%

**丢包影响：**
- 协议5：丢包率p时，效率 ≈ (1-p) × 基础效率 / (1+p×W)
- 协议6：丢包率p时，效率 ≈ (1-p) × 基础效率

**结论：**
1. 协议2-4不适合高延迟网络（效率<10%）
2. 协议5、6通过流水线显著提升效率
3. 协议6在高丢包率下效率优势更明显

### 3.8 协议选择指南

| 应用场景 | 推荐协议 | 理由 |
|---------|---------|------|
| 完美信道（教学） | 协议2 | 最简单，易于理解 |
| 低速串口（<9600bps） | 协议3 | 实现简单，足够用 |
| 交互式终端（SSH） | 协议4 | 捎带确认高效 |
| 有线局域网 | 协议5 | 性能好，实现适中 |
| 无线网络 | 协议6 | 丢包容忍度高 |
| 卫星通信 | 协议6 | 高延迟适应性强 |
| 移动互联网 | 协议6 | 延迟不稳定适应 |
| 数据中心 | 协议6 | 最高吞吐量 |

### 3.9 实际协议应用

**TCP协议：**
- 基于协议6（选择性重传）
- 增加拥塞控制
- 使用SACK（Selective ACK）选项
- 动态调整窗口大小

**HDLC协议：**
- 基于协议5（Go-Back-N）
- 用于点对点链路
- 广泛应用于广域网

**802.11 WiFi：**
- 链路层使用停等+立即ACK
- 更高层使用协议6机制
- 块确认（Block ACK）优化

**QUIC协议：**
- 基于协议6思想
- 每个流独立的选择性重传
- 比TCP更激进的重传策略

**QUIC协议：**
- 基于协议6思想
- 每个流独立的选择性重传
- 比TCP更激进的重传策略

### 3.10 协议5与协议6详细对比（实验重点）

本实验主要聚焦于协议5（Go-Back-N）和协议6（选择性重传）的性能对比，因为这两种协议：
1. 都使用滑动窗口机制，具有可比性
2. 代表了两种不同的重传策略
3. 在现代网络中有实际应用价值
4. 性能差异显著，研究价值高

#### 协议5与协议6核心差异

| 对比维度 | Go-Back-N (P5) | 选择性重传 (P6) |
|---------|---------------|----------------|
| 发送窗口 | N | N |
| 接收窗口 | 1 | N |
| 确认方式 | 累积确认 | 单独确认 |
| 重传策略 | 回退N帧 | 选择重传 |
| 缓存需求 | 小 | 大 |
| 实现复杂度 | 简单 | 复杂 |
| 效率（低丢包率）| 好 | 更好 |
| 效率（高丢包率）| 差 | 好 |
| 超时敏感性 | 高 | 低 |

**实验目标：**
通过186个系统化测试，定量分析这两种协议在不同网络条件下的性能差异，为实际协议选择提供数据支持。

---

## 四、实验操作步骤

### 4.1 环境准备

**1. 编译模拟器**
```bash
cd simulator_new
make clean
make
```

编译过程会生成可执行文件`sim`，支持协议2-6的模拟。

**2. 模拟器命令格式**
```bash
./sim <protocol> <events> <timeout> <pkt_loss> <garbled> <debug>
```

参数说明：
- `protocol`：协议编号（5或6）
- `events`：模拟事件数（通常50000）
- `timeout`：超时间隔（单位：tick，DELTA=10）
- `pkt_loss`：丢包率（0-99，百分比）
- `garbled`：校验和错误率（0-99，百分比）
- `debug`：调试标志（0=关闭，1-7=不同级别）

**示例：**
```bash
./sim 5 50000 50 10 5 0
# 协议5，50000事件，超时50，丢包率10%，错误率5%，无调试
```

### 4.2 实验一：协议性能研究

**目的：** 研究协议5的性能作为超时间隔、丢包率和校验和错误率的函数。

**实验步骤：**

1. **超时间隔影响测试**（固定丢包率10%，校验和5%）
```bash
for timeout in 20 30 40 50 60 80 100 120 150; do
    ./sim 5 50000 $timeout 10 5 0 > exp1_results/A_timeout_${timeout}.txt
done
```

2. **丢包率影响测试**（固定超时间隔50，校验和5%）
```bash
for loss in 0 5 10 15 20 25 30; do
    ./sim 5 50000 50 $loss 5 0 > exp1_results/B_loss_${loss}.txt
done
```

3. **校验和错误率影响测试**（固定超时间隔50，丢包率10%）
```bash
for cksum in 0 5 10 15 20 25; do
    ./sim 5 50000 50 10 $cksum 0 > exp1_results/C_cksum_${cksum}.txt
done
```

### 4.3 实验二：协议5与协议6性能对比

**目的：** 详细比较两种协议在各种参数下的性能。

**实验步骤：**

1. **不同丢包率下的对比**
```bash
for loss in 0 5 10 15 20 25 30; do
    ./sim 5 50000 50 $loss 5 0 > exp2_results/D_loss_${loss}_p5.txt
    ./sim 6 50000 50 $loss 5 0 > exp2_results/D_loss_${loss}_p6.txt
done
```

2. **不同超时间隔下的对比**
```bash
for timeout in 20 30 40 50 60 80 100; do
    ./sim 5 50000 $timeout 10 5 0 > exp2_results/E_timeout_${timeout}_p5.txt
    ./sim 6 50000 $timeout 10 5 0 > exp2_results/E_timeout_${timeout}_p6.txt
done
```

3. **不同校验和错误率下的对比**
```bash
for cksum in 0 5 10 15 20 25; do
    ./sim 5 50000 50 10 $cksum 0 > exp2_results/F_cksum_${cksum}_p5.txt
    ./sim 6 50000 50 10 $cksum 0 > exp2_results/F_cksum_${cksum}_p6.txt
done
```

### 4.4 实验三：事件优先级研究

**目的：** 研究pick_event()函数中事件优先级对协议性能的影响。

**实验步骤：**

1. **测试原始优先级**（帧到达优先）
```bash
./sim 5 50000 50 10 5 0 > exp3_results/priority_original.txt
```

2. **修改worker.c测试超时优先**
```c
case 5:
    if (check_timers() >= 0) return(timeout);
    if (nframes > 0) return((int)frametype());
    if (network_layer_status) return(network_layer_ready);
    return(NO_EVENT);
```
重新编译并测试：
```bash
make clean && make
./sim 5 50000 50 10 5 0 > exp3_results/priority_timeout_first.txt
```

3. **修改worker.c测试网络层就绪优先**
```c
case 5:
    if (network_layer_status) return(network_layer_ready);
    if (nframes > 0) return((int)frametype());
    if (check_timers() >= 0) return(timeout);
    return(NO_EVENT);
```
重新编译并测试：
```bash
make clean && make
./sim 5 50000 50 10 5 0 > exp3_results/priority_network_first.txt
```

### 4.5 实验四：重传帧数量研究

**目的：** 调查重传帧数量作为超时间隔和丢包率的函数。

**实验步骤：**

1. **协议5重传研究**（9种超时 × 6种丢包率）
```bash
for timeout in 20 30 40 50 60 80 100 120 150; do
    for loss in 0 5 10 15 20 25; do
        ./sim 5 50000 $timeout $loss 5 0 > exp4_results/P5_t${timeout}_l${loss}.txt
    done
done
```

2. **协议6重传研究**（9种超时 × 6种丢包率）
```bash
for timeout in 20 30 40 50 60 80 100 120 150; do
    for loss in 0 5 10 15 20 25; do
        ./sim 6 50000 $timeout $loss 5 0 > exp4_results/P6_t${timeout}_l${loss}.txt
    done
done
```

### 4.6 实验五：模拟器时间推进优化

**目的：** 优化模拟器，使其在两个进程都等待时能更快地推进时间。

**实验步骤：**

1. **测试原始版本性能**
```bash
time ./sim 5 100000 100 10 5 0 > exp5_results/original_perf.txt
```

2. **修改sim.c主循环**
```c
while (tick < last_tick) {
    process = rand() & 1;
    
    // 优化：两个进程都等待时快速推进
    if (hanging[0] >= DELTA && hanging[1] >= DELTA) {
        tick = tick + DELTA * 10;
        // ... 处理读写 ...
    } else {
        tick = tick + DELTA;
        // ... 正常处理 ...
    }
    // ...
}
```

3. **测试优化版本性能**
```bash
make clean && make
time ./sim 5 100000 100 10 5 0 > exp5_results/optimized_perf.txt
```

### 4.7 实验六：网络延迟影响研究

**目的：** 研究网络延迟变化对协议性能的影响。

**实验步骤：**

通过不同的超时间隔模拟不同的网络延迟环境：

```bash
# 协议5延迟测试
for timeout in 30 50 70 100 150; do
    ./sim 5 50000 $timeout 10 5 0 > exp6_results/p5_delay_${timeout}.txt
done

# 协议6延迟测试
for timeout in 30 50 70 100 150; do
    ./sim 6 50000 $timeout 10 5 0 > exp6_results/p6_delay_${timeout}.txt
done
```

---

## 五、实验结果与数据分析

### 5.1 实验一结果：协议性能研究

#### 5.1.1 超时间隔对性能的影响

**实验设置：** 固定协议5，丢包率10%，校验和错误率5%，变化超时间隔

**执行命令示例：**
```bash
# 超时间隔20
./sim 5 50000 20 10 5 0 > exp1_results/A_timeout_20.txt

# 超时间隔50
./sim 5 50000 50 10 5 0 > exp1_results/A_timeout_50.txt

# 超时间隔100
./sim 5 50000 100 10 5 0 > exp1_results/A_timeout_100.txt
```

**原始输出示例（超时间隔50）：**
```
Protocol   : 5
Events     : 50000
Timeout    : 50
Pkt_loss   : 10
Garbled    : 5
--------------------------
Efficiency : 48%
Frames_sent: 17554
Retransmit : 9051
Timeouts   : 1293
Ack_recd   : 8494
Payload    : 8494
Lost       : 1842
Bad        : 764
```

**完整测试数据对比表：**

| 超时间隔 | 命令 | 效率(%) | 重传帧数 | 超时次数 | 发送帧数 | 接受载荷数 | 丢包数 | 坏帧数 |
|---------|------|---------|---------|---------|---------|-----------|--------|--------|
| 20 | `./sim 5 50000 20 10 5 0` | 36 | 16303 | 2329 | 25855 | 9543 | 2710 | 1120 |
| 30 | `./sim 5 50000 30 10 5 0` | 43 | 12341 | 1763 | 22025 | 9680 | 2302 | 963 |
| 40 | `./sim 5 50000 40 10 5 0` | 45 | 10689 | 1527 | 19804 | 9109 | 2006 | 891 |
| **50** | `./sim 5 50000 50 10 5 0` | **48** | **9051** | **1293** | **17554** | **8494** | **1842** | **764** |
| 60 | `./sim 5 50000 60 10 5 0` | 46 | 8239 | 1177 | 15569 | 7316 | 1566 | 753 |
| 80 | `./sim 5 50000 80 10 5 0` | 46 | 6559 | 937 | 12244 | 5677 | 1294 | 533 |
| 100 | `./sim 5 50000 100 10 5 0` | 46 | 5495 | 785 | 10305 | 4801 | 1100 | 449 |
| 120 | `./sim 5 50000 120 10 5 0` | 45 | 4753 | 679 | 8772 | 4010 | 929 | 391 |
| 150 | `./sim 5 50000 150 10 5 0` | 47 | 3815 | 545 | 7216 | 3394 | 770 | 319 |

**数据分析：**
1. **最优点：** 超时间隔为50时效率最高（48%），此时重传9051帧，超时1293次
2. **超时过短（20-30）：** 
   - 超时20时：效率仅36%，重传16303帧（是最优值的1.8倍）
   - 超时次数高达2329次，说明大量ACK在传输途中被误判为超时
   - 每次超时导致回退N帧，造成严重的带宽浪费
3. **超时过长（100-150）：** 
   - 重传和超时次数显著减少（3815-5495帧）
   - 但接受载荷数也大幅下降（3394-4801），说明吞吐量降低
   - 效率虽然保持在45-47%，但绝对性能（payload/秒）下降
4. **结论：** 
   - 存在最优超时间隔，在本实验环境下为50ms
   - 最优值需要根据网络RTT（往返时延）动态调整
   - 推荐公式：`超时间隔 = 2×RTT + 安全余量`

#### 5.1.2 丢包率对性能的影响

**实验设置：** 固定协议5，超时间隔50，校验和错误率5%，变化丢包率

**执行命令示例：**
```bash
# 丢包率0%
./sim 5 50000 50 0 5 0 > exp1_results/B_loss_0.txt

# 丢包率10%
./sim 5 50000 50 10 5 0 > exp1_results/B_loss_10.txt

# 丢包率30%
./sim 5 50000 50 30 5 0 > exp1_results/B_loss_30.txt
```

**原始输出对比示例：**

丢包率0%输出：
```
Protocol   : 5
Efficiency : 71%
Frames_sent: 18382
Retransmit : 5194
Lost       : 0
```

丢包率30%输出：
```
Protocol   : 5
Efficiency : 22%
Frames_sent: 16374
Retransmit : 12649
Lost       : 4918
```

**完整测试数据对比表：**

| 丢包率 | 命令 | 效率(%) | 重传帧数 | 超时次数 | 发送帧数 | 接受载荷数 | 丢包数 | 坏帧数 |
|--------|------|---------|---------|---------|---------|-----------|--------|--------|
| 0% | `./sim 5 50000 50 0 5 0` | 71 | 5194 | 742 | 18382 | 13184 | 0 | 933 |
| 5% | `./sim 5 50000 50 5 5 0` | 57 | 7560 | 1080 | 18006 | 10437 | 917 | 867 |
| 10% | `./sim 5 50000 50 10 5 0` | 46 | 9352 | 1336 | 17570 | 8058 | 1836 | 772 |
| 15% | `./sim 5 50000 50 15 5 0` | 37 | 10752 | 1536 | 17335 | 6576 | 2638 | 749 |
| 20% | `./sim 5 50000 50 20 5 0` | 30 | 11753 | 1679 | 16915 | 5160 | 3512 | 654 |
| 25% | `./sim 5 50000 50 25 5 0` | 25 | 12376 | 1768 | 16612 | 4228 | 4250 | 605 |
| 30% | `./sim 5 50000 50 30 5 0` | 22 | 12649 | 1807 | 16374 | 3712 | 4918 | 599 |

**数据分析：**
1. **线性下降趋势：** 
   - 丢包率从0%到30%，效率从71%降至22%
   - 呈现近似线性的负相关关系
   - 效率下降率：约-1.6%每1%丢包率增加

2. **重传帧数激增：**
   - 0%丢包率：5194帧重传（主要因校验和错误）
   - 30%丢包率：12649帧重传（增加144%）
   - 丢包率每增加5%，重传约增加1000-2000帧

3. **Go-Back-N缺陷暴露：**
   - 每次丢包触发回退N帧重传
   - 高丢包率时，窗口内多个帧需重传
   - 例如：30%丢包率时，发送16374帧，重传12649帧，重传率77%

4. **丢包数与效率关系：**
   - 丢包数从0增至4918（30%丢包率）
   - 每个丢包导致约2.6次重传（12649/4918）
   - 说明Go-Back-N的"连锁反应"效应

5. **实际应用建议：**
   - P5协议适用于丢包率<10%的网络（效率>46%）
   - 丢包率>15%时效率<37%，应考虑协议6
   - 丢包率>25%时P5基本不可用（效率<25%）

#### 5.1.3 校验和错误率对性能的影响

**实验设置：** 固定协议5，超时间隔50，丢包率10%，变化校验和错误率

**执行命令示例：**
```bash
# 校验和错误率0%
./sim 5 50000 50 10 0 0 > exp1_results/C_cksum_0.txt

# 校验和错误率10%
./sim 5 50000 50 10 10 0 > exp1_results/C_cksum_10.txt

# 校验和错误率25%
./sim 5 50000 50 10 25 0 > exp1_results/C_cksum_25.txt
```

**原始输出示例（校验和0% vs 25%）：**

校验和0%：
```
Protocol   : 5
Efficiency : 55%
Retransmit : 8120
Bad        : 0
Frames_sent: 18100
```

校验和25%：
```
Protocol   : 5
Efficiency : 24%
Retransmit : 12355
Bad        : 3557
Frames_sent: 16322
```

**完整测试数据对比表：**

| 校验和错误率 | 命令 | 效率(%) | 重传帧数 | 超时次数 | 发送帧数 | 接受载荷数 | 丢包数 | 坏帧数 |
|-------------|------|---------|---------|---------|---------|-----------|--------|--------|
| 0% | `./sim 5 50000 50 10 0 0` | 55 | 8120 | 1160 | 18100 | 9974 | 1827 | 0 |
| 5% | `./sim 5 50000 50 10 5 0` | 48 | 9002 | 1286 | 17579 | 8564 | 1846 | 733 |
| 10% | `./sim 5 50000 50 10 10 0` | 39 | 10360 | 1480 | 17058 | 6685 | 1758 | 1507 |
| 15% | `./sim 5 50000 50 10 15 0` | 34 | 10983 | 1569 | 16742 | 5752 | 1798 | 2150 |
| 20% | `./sim 5 50000 50 10 20 0` | 28 | 11788 | 1684 | 16528 | 4728 | 1716 | 2954 |
| 25% | `./sim 5 50000 50 10 25 0` | 24 | 12355 | 1765 | 16322 | 3953 | 1660 | 3557 |

**数据分析：**
1. **显著影响：** 
   - 校验和错误率从0%到25%，效率从55%降至24%
   - 效率下降率：约-1.24%每1%错误率增加
   - 影响程度比丢包略小，但仍然显著

2. **坏帧数量增长：**
   - 错误率与坏帧数成正比关系
   - 5%错误率：733个坏帧
   - 25%错误率：3557个坏帧（增加4.9倍）
   - 平均每5%错误率增加约700-800个坏帧

3. **双重代价分析：**
   - **传输代价：** 坏帧占用信道时间但无效
   - **重传代价：** 坏帧触发超时重传
   - 例如：25%错误率时，3557个坏帧 + 12355次重传 = 15912次无效传输
   - 无效传输占总发送帧的97%（15912/16322）

4. **与丢包对比：**
   - 同样10%错误率：丢包导致46%效率，校验和导致39%效率
   - 校验和错误更"浪费"：帧实际传输了但被丢弃
   - 丢包则节省了传输时间（虽然效率略高）

5. **实际意义：**
   - 说明物理层质量的重要性
   - 良好的信道编码和调制方式可显著提升性能
   - 在无线网络中，信号强度直接影响校验和错误率
   - 建议：优先改善物理层质量，再调整协议参数

### 5.2 实验二结果：协议5与协议6性能对比

#### 5.2.1 不同丢包率下的对比

**实验设置：** 固定超时间隔50，校验和错误率5%，变化丢包率，对比协议5和协议6

**执行命令示例：**
```bash
# 协议5，丢包率10%
./sim 5 50000 50 10 5 0 > exp2_results/D_loss_10_p5.txt

# 协议6，丢包率10%
./sim 6 50000 50 10 5 0 > exp2_results/D_loss_10_p6.txt
```

**原始输出对比示例（丢包率10%）：**

协议5输出：
```
Protocol   : 5
Efficiency : 47%
Frames_sent: 17566
Retransmit : 9233
Timeouts   : 1319
Payload    : 8320
Lost       : 1715
```

协议6输出：
```
Protocol   : 6
Efficiency : 77%
Frames_sent: 14316
Retransmit : 1848
Timeouts   : 1846
Payload    : 11131
Lost       : 1515
```

**完整测试数据对比表：**

| 丢包率 | 协议 | 命令 | 效率(%) | 重传帧数 | 超时次数 | 发送帧数 | 接受载荷数 | 丢包数 | 坏帧数 |
|--------|------|------|---------|---------|---------|---------|-----------|--------|--------|
| 0% | P5 | `./sim 5 50000 50 0 5 0` | 72 | 5054 | 722 | 18316 | 13255 | 0 | 905 |
| 0% | P6 | `./sim 6 50000 50 0 5 0` | 93 | 267 | 270 | 16794 | 15676 | 0 | 880 |
| 5% | P5 | `./sim 5 50000 50 5 5 0` | 61 | 6909 | 987 | 18072 | 11158 | 964 | 832 |
| 5% | P6 | `./sim 6 50000 50 5 5 0` | 85 | 1068 | 1068 | 15465 | 13295 | 816 | 681 |
| 10% | P5 | `./sim 5 50000 50 10 5 0` | 47 | 9233 | 1319 | 17566 | 8320 | 1715 | 857 |
| 10% | P6 | `./sim 6 50000 50 10 5 0` | 77 | 1848 | 1846 | 14316 | 11131 | 1515 | 588 |
| 15% | P5 | `./sim 5 50000 50 15 5 0` | 38 | 10591 | 1513 | 17224 | 6624 | 2609 | 750 |
| 15% | P6 | `./sim 6 50000 50 15 5 0` | 69 | 2724 | 2724 | 13056 | 9076 | 2079 | 510 |
| 20% | P5 | `./sim 5 50000 50 20 5 0` | 30 | 11732 | 1676 | 16841 | 5097 | 3468 | 708 |
| 20% | P6 | `./sim 6 50000 50 20 5 0` | 62 | 3399 | 3399 | 12172 | 7606 | 2510 | 499 |
| 25% | P5 | `./sim 5 50000 50 25 5 0` | 25 | 12432 | 0 | 16644 | 4414 | 4246 | 604 |
| 25% | P6 | `./sim 6 50000 50 25 5 0` | 56 | 3977 | 3977 | 11533 | 6528 | 2935 | 410 |
| 30% | P5 | `./sim 5 50000 50 30 5 0` | 21 | 12754 | 1822 | 16359 | 3592 | 4946 | 574 |
| 30% | P6 | `./sim 6 50000 50 30 5 0` | 51 | 4464 | 4464 | 11009 | 5624 | 3272 | 408 |

**性能提升对比表：**

| 丢包率 | P5效率(%) | P6效率(%) | P5重传 | P6重传 | 效率提升 | 重传减少 | P6优势分析 |
|--------|-----------|-----------|--------|--------|---------|---------|------------|
| 0% | 72 | 93 | 5054 | 267 | +29% | -95% | 理想环境下P6也有明显优势 |
| 5% | 61 | 85 | 6909 | 1068 | +39% | -85% | 低丢包率优势明显 |
| 10% | 47 | 77 | 9233 | 1848 | +64% | -80% | 中等丢包率差距扩大 |
| 15% | 38 | 69 | 10591 | 2724 | +82% | -74% | 高丢包率P5急剧下降 |
| 20% | 30 | 62 | 11732 | 3399 | +107% | -71% | P6效率是P5的2倍 |
| 25% | 25 | 56 | 12432 | 3977 | +124% | -68% | P5几乎不可用 |
| 30% | 21 | 51 | 12754 | 4464 | +143% | -65% | P6仍保持51%效率 |

**数据深度分析：**

1. **全面优势：** 
   - P6在所有丢包率（0-30%）下都显著优于P5
   - 即使在0%丢包的理想环境，P6效率也高出21个百分点

2. **差距递增规律：**
   - 丢包率越高，P6的相对优势越明显
   - 0%丢包：P6提升29%
   - 30%丢包：P6提升143%（2.4倍）
   - 增长趋势接近指数级

3. **重传控制能力：**
   - P6的重传次数是P5的5%-35%
   - 10%丢包率：P6重传1848帧 vs P5重传9233帧（节省80%）
   - 30%丢包率：P6重传4464帧 vs P5重传12754帧（节省65%）
   - P5每次丢包导致窗口内所有帧重传（Go-Back-N机制）
   - P6只重传丢失的帧（选择性重传机制）

4. **高丢包环境表现：**
   - 30%丢包率下：
     * P5：效率21%，接受载荷3592，几乎不可用
     * P6：效率51%，接受载荷5624，仍能正常工作
   - P6在恶劣网络下保持可用性

5. **实际应用建议：**
   - 丢包率<5%：P5可用但P6更优
   - 丢包率5-15%：强烈推荐P6（效率提升64-82%）
   - 丢包率>15%：必须使用P6，P5不可接受

#### 5.2.2 不同超时间隔下的对比

**实验设置：** 固定丢包率10%，校验和错误率5%，变化超时间隔，对比协议5和协议6

**执行命令示例：**
```bash
# 协议5，超时间隔20
./sim 5 50000 20 10 5 0 > exp2_results/E_timeout_20_p5.txt

# 协议6，超时间隔20
./sim 6 50000 20 10 5 0 > exp2_results/E_timeout_20_p6.txt
```

**完整测试数据对比表：**

| 超时间隔 | 协议 | 命令 | 效率(%) | 重传帧数 | 超时次数 | 发送帧数 | 接受载荷数 |
|---------|------|------|---------|---------|---------|---------|-----------|
| 20 | P5 | `./sim 5 50000 20 10 5 0` | 36 | 16394 | 2342 | 25939 | 9541 |
| 20 | P6 | `./sim 6 50000 20 10 5 0` | 72 | 3436 | 3436 | 18640 | 13466 |
| 30 | P5 | `./sim 5 50000 30 10 5 0` | 45 | 12005 | 1715 | 21871 | 9854 |
| 30 | P6 | `./sim 6 50000 30 10 5 0` | 77 | 2214 | 2214 | 16925 | 13069 |
| 40 | P5 | `./sim 5 50000 40 10 5 0` | 46 | 10549 | 1507 | 19832 | 9278 |
| 40 | P6 | `./sim 6 50000 40 10 5 0` | 77 | 2120 | 2120 | 15420 | 11974 |
| 50 | P5 | `./sim 5 50000 50 10 5 0` | 45 | 9443 | 1349 | 17423 | 7975 |
| 50 | P6 | `./sim 6 50000 50 10 5 0` | 77 | 1945 | 1945 | 14118 | 10909 |
| 60 | P5 | `./sim 5 50000 60 10 5 0` | 47 | 8204 | 1172 | 15535 | 7324 |
| 60 | P6 | `./sim 6 50000 60 10 5 0` | 77 | 1830 | 915 | 13134 | 10246 |
| 80 | P5 | `./sim 5 50000 80 10 5 0` | 47 | 6531 | 933 | 12472 | 5927 |
| 80 | P6 | `./sim 6 50000 80 10 5 0` | 77 | 1515 | 1515 | 11459 | 8931 |
| 100 | P5 | `./sim 5 50000 100 10 5 0` | 48 | 5327 | 761 | 10396 | 5061 |
| 100 | P6 | `./sim 6 50000 100 10 5 0` | 78 | 1270 | 0 | 10440 | 8012 |

**数据深度分析：**

1. **稳定性对比：** 
   - P5效率波动：36-48%（波动范围12个百分点）
   - P6效率稳定：72-78%（波动范围6个百分点）
   - P6对超时参数不敏感，部署更简单

2. **超时敏感性分析：**
   - **P5在超时20时：**
     * 效率仅36%（最低）
     * 重传16394帧（最高）
     * 超时2342次（最频繁）
     * 说明过短超时导致大量误判
   
   - **P6在超时20时：**
     * 效率仍有72%
     * 重传3436帧（是P5的21%）
     * 即使在非最优超时下，P6仍能保持高效

3. **最佳超时间隔：**
   - P5最佳：100ms（效率48%）
   - P6最佳：100ms（效率78%）
   - 但P6在30-100ms区间效率都是77-78%，选择余地大

4. **重传差异：**
   - 即使在P5最佳超时（100ms），P6重传仍少76%
   - P5：5327帧重传
   - P6：1270帧重传
   - 说明协议机制差异远大于参数调优效果

5. **实用价值：**
   - P5需要精确调整超时间隔（±10ms影响效率3-12%）
   - P6无需精确调优（30-100ms范围内效率稳定）
   - 在网络RTT波动的环境中，P6更可靠

#### 5.2.3 不同校验和错误率下的对比

| 校验和错误率 | P5效率(%) | P6效率(%) | P5重传 | P6重传 |
|-------------|-----------|-----------|--------|--------|
| 0% | 54 | 85 | 8225 | 1115 |
| 5% | 47 | 77 | 9121 | 1978 |
| 10% | 39 | 70 | 10444 | 2569 |
| 15% | 31 | 63 | 11536 | 3190 |
| 20% | 28 | 57 | 11718 | 3898 |
| 25% | 22 | 53 | 12537 | 4263 |

**分析：**
1. **持续优势：** 即使在25%错误率下，P6效率仍是P5的2.4倍
2. **降级优雅：** P6性能随错误率增加平缓下降，P5下降陡峭
3. **适应性强：** P6在恶劣信道条件下仍能保持合理性能

### 5.3 实验三结果：事件优先级研究

**实验目的：** 研究worker.c中pick_event()函数的事件优先级对协议5性能的影响

**实验设置：** 固定协议5，超时间隔50，丢包率10%，校验和错误率5%

**测试配置说明：**

1. **原始配置（帧到达优先）：**
```c
// worker.c中pick_event()的case 5原始代码
case 5:
    if (nframes > 0) return((int)frametype());  // 优先处理帧到达
    if (check_timers() >= 0) return(timeout);    // 其次处理超时
    if (network_layer_status) return(network_layer_ready);  // 最后处理网络层
    return(NO_EVENT);
```
执行命令：`./sim 5 50000 50 10 5 0 > exp3_results/priority_original.txt`

2. **超时优先配置：**
```c
// 修改后的代码
case 5:
    if (check_timers() >= 0) return(timeout);    // 优先处理超时
    if (nframes > 0) return((int)frametype());   // 其次处理帧到达
    if (network_layer_status) return(network_layer_ready);
    return(NO_EVENT);
```
执行命令：`make clean && make && ./sim 5 50000 50 10 5 0 > exp3_results/priority_timeout_first.txt`

3. **网络层就绪优先配置：**
```c
// 修改后的代码
case 5:
    if (network_layer_status) return(network_layer_ready);  // 优先网络层
    if (nframes > 0) return((int)frametype());   // 其次帧到达
    if (check_timers() >= 0) return(timeout);    // 最后超时
    return(NO_EVENT);
```
执行命令：`make clean && make && ./sim 5 50000 50 10 5 0 > exp3_results/priority_network_first.txt`

**原始输出示例：**

原始配置输出：
```
Protocol   : 5
Efficiency : 46%
Frames_sent: 17632
Retransmit : 9415
Timeouts   : 1345
Payload    : 8209
```

超时优先输出：
```
Protocol   : 5
Efficiency : 47%
Frames_sent: 17952
Retransmit : 9456
Timeouts   : 1384
Payload    : 8490
```

**完整测试数据对比表：**

| 优先级方案 | 命令 | 效率(%) | 重传帧数 | 超时次数 | 发送帧数 | 接受载荷数 | 效率排名 |
|-----------|------|---------|---------|---------|---------|-----------|---------|
| 帧到达优先（原始） | 原始编译 | 46 | 9415 | 1345 | 17632 | 8209 | 2 |
| 超时优先 | 修改后编译 | 47 | 9456 | 1384 | 17952 | 8490 | 1 |
| 网络层就绪优先 | 修改后编译 | 45 | 9702 | 1386 | 17925 | 8214 | 3 |

**数据深度分析：**

1. **性能差异很小：**
   - 三种方案效率差异仅2%（45-47%）
   - 接受载荷数差异：276帧（8214-8490）
   - 相对于总载荷（~8300），差异仅3.3%

2. **超时优先略优原因：**
   - 效率47%，比原始高1个百分点
   - 接受载荷多281帧（8490 vs 8209）
   - 快速处理超时可以更早重传丢失的帧
   - 减少了接收方等待时间

3. **网络层优先最差原因：**
   - 效率45%，重传9702帧（最多）
   - 优先发送新帧，延迟处理接收和超时
   - 导致发送窗口快速填满，但ACK处理不及时
   - 更多不必要的超时重传

4. **原始设计合理性：**
   - 帧到达优先是折中方案
   - 优先处理接收帧，及时发送ACK
   - 减少发送方不必要的重传
   - 性能居中（46%），是经过权衡的设计

5. **结论：**
   - 事件优先级不是性能瓶颈（差异<5%）
   - 协议机制（P5 vs P6）的影响远大于事件优先级
   - 原始设计（帧到达优先）已足够合理
   - 在本测试环境下（丢包率10%），优化空间有限
   - 实际应用中无需特别调整事件优先级

### 5.4 实验四结果：重传帧数量研究

#### 5.4.1 协议5最佳超时间隔分析

根据实验数据，不同丢包率下的最佳超时间隔：

| 丢包率 | 最佳超时间隔 | 最低重传帧数 | 效率(%) |
|--------|-------------|-------------|---------|
| 0% | 60-80 | 4207-4872 | 70-71 |
| 5% | 60-80 | 5530-6615 | 58-59 |
| 10% | 40-60 | 8183-9639 | 45-47 |
| 15% | 60-80 | 7343-9254 | 37-38 |
| 20% | 60-100 | 6384-10101 | 30-31 |
| 25% | 80-120 | 5481-8071 | 25-26 |

**趋势分析：**
1. 丢包率越高，最佳超时间隔越大
2. 低丢包率（0-10%）：最佳超时40-80ms
3. 高丢包率（15-25%）：最佳超时60-120ms
4. 通用推荐：50-80ms适用于大多数情况

#### 5.4.2 协议6重传特征分析

| 超时间隔 | 丢包率0% | 丢包率10% | 丢包率20% | 丢包率25% |
|---------|---------|----------|----------|----------|
| 20 | 1168 | 3328 | 5917 | 7026 |
| 50 | 220 | 1948 | 3380 | 4025 |
| 100 | 264 | 1328 | 2050 | 2289 |
| 150 | 248 | 1035 | 1554 | 1642 |

**特征：**
1. **不敏感：** P6对超时间隔变化不敏感
2. **稳定：** 各种超时下性能都很好
3. **优化空间小：** 调整超时带来的性能提升有限（<5%）
4. **部署友好：** 无需精确调优，默认50-100ms即可

### 5.5 实验五结果：模拟器时间推进优化

| 版本 | 运行时间(秒) | 效率(%) | 重传帧数 | 超时次数 | 性能提升 |
|------|-------------|---------|---------|---------|---------|
| 原始版本 | 4.448 | 47 | 10948 | 1564 | - |
| 优化版本 | 4.245 | 46 | 10997 | 1571 | 4.6% |

**分析：**
1. **提速效果：** 运行时间减少0.203秒，提速4.6%
2. **正确性：** 效率和重传次数基本一致，协议行为未改变
3. **优化原理：** 两个进程都等待时，时间推进速度从1×DELTA变为10×DELTA
4. **适用场景：** 高超时间隔、低事件密度时效果更明显

### 5.6 实验六结果：网络延迟影响研究

#### 5.6.1 协议5延迟适应性

| 延迟环境 | 超时间隔 | 效率(%) | 重传帧数 | 超时次数 |
|---------|---------|---------|---------|---------|
| 低延迟 | 30 | 46 | 11893 | 1699 |
| 中等延迟 | 50 | 45 | 9618 | 1374 |
| 中高延迟 | 70 | 48 | 7182 | 1026 |
| 高延迟 | 100 | 44 | 5530 | 790 |
| 极高延迟 | 150 | 47 | 3829 | 547 |

**分析：**
- P5在中高延迟（70ms）时效率最高（48%）
- 延迟过低或过高都会降低效率
- 效率波动范围：44-48%（波动4%）

#### 5.6.2 协议6延迟适应性

| 延迟环境 | 超时间隔 | 效率(%) | 重传帧数 | 超时次数 |
|---------|---------|---------|---------|---------|
| 低延迟 | 30 | 76 | 2365 | 2365 |
| 中等延迟 | 50 | 77 | 1873 | 1873 |
| 中高延迟 | 70 | 78 | 1527 | 1527 |
| 高延迟 | 100 | 77 | 1361 | 1361 |
| 极高延迟 | 150 | 78 | 1051 | 1051 |

**分析：**
- P6在各种延迟下效率稳定在76-78%
- 效率波动仅2%，远小于P5的4%
- 重传次数随延迟增加而减少
- 证明P6具有优秀的网络适应性

#### 5.6.3 延迟环境对比总结

| 延迟环境 | P5效率 | P6效率 | P6优势 | P5重传 | P6重传 | 重传减少 |
|---------|--------|--------|--------|--------|--------|---------|
| 低(30) | 46% | 76% | +65% | 11893 | 2365 | -80% |
| 中(50) | 45% | 77% | +71% | 9618 | 1873 | -81% |
| 高(100) | 44% | 77% | +75% | 5530 | 1361 | -75% |
| 极高(150) | 47% | 78% | +66% | 3829 | 1051 | -73% |

**核心结论：**
1. P6在所有延迟环境下效率均提升65-75%
2. P6对延迟变化不敏感，部署无需精确调优
3. P6重传次数始终比P5少73-81%
4. P6适用于延迟不稳定的复杂网络环境

---

## 六、实验问题回答

### 问题1：协议性能作为超时间隔、丢包率和校验和错误率的函数

**回答：**

**超时间隔的影响：**
- 存在最优值（约50ms），过短或过长都会降低效率
- 超时过短：大量不必要的重传（如20ms时重传16303帧）
- 超时过长：虽然重传减少，但等待时间长，吞吐量下降
- 建议值：协议5使用40-80ms

**丢包率的影响：**
- 对性能影响最大，呈线性下降趋势
- Go-Back-N在高丢包率下性能急剧恶化
- 从0%到30%丢包率，效率从71%降至22%
- 每5%丢包率增加导致效率下降约8-10个百分点

**校验和错误率的影响：**
- 显著影响性能，从0%到25%，效率从55%降至24%
- 坏帧造成双重代价：浪费传输+需要重传
- 说明物理层质量的重要性

**结论：** 在实际应用中，应优先选择低丢包率的网络路径，其次考虑物理层质量，最后调整超时参数。

### 问题2：协议5和协议6的性能比较

**回答：**

**定量对比：**
- 效率：P6比P5高30-143%（取决于丢包率）
- 重传：P6重传次数是P5的5-35%
- 稳定性：P6效率波动小（76-93%），P5波动大（22-72%）

**协议5更好的情况：**
1. **极低丢包率环境（<1%）且资源受限：**
   - P5实现简单，接收缓存需求小（仅1帧）
   - 在理想信道下，P5效率可达70%以上
   - 适合嵌入式系统、简单设备

2. **短距离、高可靠链路：**
   - 局域网、光纤直连等场景
   - 信道质量好，丢包和错误率极低

**协议6更好的情况：**
1. **中高丢包率环境（>5%）：**
   - 无线网络、移动通信、卫星链路
   - P6效率显著优于P5（提升39-143%）

2. **延迟不稳定的网络：**
   - 广域网、互联网
   - P6对超时间隔不敏感，适应性强

3. **高吞吐量需求：**
   - 数据中心、骨干网
   - P6重传少，带宽利用率高

4. **长距离通信：**
   - RTT较大的场景
   - P6选择性重传避免大量重复传输

**综合建议：**
- **生产环境首选协议6**：性能优势明显，适应性强
- **资源受限环境可选协议5**：实现简单，成本低
- **现代网络推荐协议6**：无线、移动、广域网等复杂环境

### 问题3：事件优先级对协议性能的影响

**回答：**

**实验结果：**
- 原始（帧到达优先）：效率46%，重传9415帧
- 超时优先：效率47%，重传9456帧
- 网络层就绪优先：效率45%，重传9702帧

**性能差异分析：**
1. **差异较小：** 三种方案性能差异仅2%（45-47%）
2. **略优配置：** 超时优先效率最高（47%），但优势不明显
3. **最差配置：** 网络层就绪优先导致更多重传（9702帧）

**原因分析：**

1. **帧到达优先（原始）：**
   - 优先处理接收帧，减少接收缓存压力
   - 及时确认，减少发送方不必要的重传
   - 折中方案，平衡各类事件

2. **超时优先：**
   - 优先处理超时，快速重传丢失的帧
   - 减少等待时间，提高响应速度
   - 但可能忽略已到达的帧，增加缓存压力

3. **网络层就绪优先：**
   - 优先发送新帧，最大化发送窗口利用
   - 但延迟处理接收和超时，导致更多重传
   - 不适合丢包环境

**结论：**
- 事件优先级不是性能瓶颈
- 原始设计（帧到达优先）已经过良好权衡
- 在丢包率10%的测试环境下，优化空间有限
- 实际应用中无需特别调整事件优先级

### 问题4：重传帧数量作为超时间隔的函数，最佳设置

**回答：**

**协议5最佳超时间隔：**

| 网络条件 | 丢包率 | 最佳超时间隔 | 预期效率 |
|---------|--------|-------------|---------|
| 优秀 | 0-5% | 60-80ms | 58-71% |
| 良好 | 5-10% | 40-60ms | 45-58% |
| 一般 | 10-15% | 60-80ms | 37-45% |
| 较差 | 15-25% | 80-120ms | 25-37% |

**协议6最佳超时间隔：**
- 推荐范围：50-100ms
- 对超时间隔不敏感，无需精确调优
- 任何合理值（30-150ms）都能保持高效率（76-78%）

**确定最佳设置的方法：**

1. **测量网络RTT：**
   ```
   最佳超时 = RTT × 2 + 安全余量
   安全余量 = RTT × (0.5 ~ 1.0)
   ```

2. **根据丢包率调整：**
   - 低丢包率（<10%）：较短超时（40-60ms）
   - 高丢包率（>15%）：较长超时（80-120ms）

3. **动态自适应：**
   - 监测重传率和超时率
   - 重传过多：增加超时间隔
   - 超时频繁：减少超时间隔
   - 目标：最小化（重传率 + 超时率）

**实践建议：**
- 协议5：初始值50ms，根据网络RTT动态调整
- 协议6：固定50-100ms，无需动态调整
- 现代网络：优先选择协议6，避免复杂的超时优化

### 问题5：模拟器时间推进优化

**回答：**

**优化方案：**
修改sim.c主循环，检测两个进程都在等待的情况：

```c
while (tick < last_tick) {
    process = rand() & 1;
    
    // 优化：两个进程都在等待时快速推进
    if (hanging[0] >= DELTA && hanging[1] >= DELTA) {
        // 加速：跳过10个时间单位
        tick = tick + DELTA * 10;
        rfd = (process == 0 ? r4 : r6);
        if (read(rfd, &word, TICK_SIZE) != TICK_SIZE) 
            terminate("");
        if (word == OK) 
            hanging[process] = 0;
        if (word == NOTHING) 
            hanging[process] += DELTA * 10;
    } else {
        // 正常：推进1个时间单位
        tick = tick + DELTA;
        rfd = (process == 0 ? r4 : r6);
        if (read(rfd, &word, TICK_SIZE) != TICK_SIZE) 
            terminate("");
        if (word == OK) 
            hanging[process] = 0;
        if (word == NOTHING) 
            hanging[process] += DELTA;
    }
    
    if (hanging[0] >= DEADLOCK && hanging[1] >= DEADLOCK)
        terminate("A deadlock has been detected");
    
    // 通知选定进程运行
    wfd = (process == 0 ? w3 : w5);
    if (write(wfd, &tick, TICK_SIZE) != TICK_SIZE)
        terminate("Main could not write to worker");
}
```

**优化效果：**
- 运行时间：从4.448秒降至4.245秒
- 性能提升：4.6%
- 协议行为：保持一致（效率46-47%）

**优化原理：**
1. 检测空闲期：两个进程都在等待超时
2. 快速跳过：时间推进速度×10
3. 减少无效循环：避免大量"什么都不做"的迭代

**进一步优化空间：**
1. **智能跳跃：** 跳转到最近的超时时间点
2. **事件驱动：** 维护事件优先队列，直接跳到下一事件
3. **并行处理：** 利用多核处理两个进程

**实际价值：**
- 大规模仿真（events > 100000）时效果更明显
- 高超时间隔（>100ms）时提速更显著
- 对理解和验证协议正确性有帮助

### 问题6：可变数据包传递时间对协议性能的影响

**回答：**

**实验设计：**
通过不同的超时间隔模拟不同的网络延迟环境（30-150ms），研究延迟变化对两种协议的影响。

**延迟方差的影响：**

**协议5（Go-Back-N）：**
- 延迟不稳定导致效率波动（44-48%，波动4%）
- 短延迟（30ms）：过早超时，重传11893帧
- 长延迟（150ms）：等待时间长，吞吐量下降
- 最优延迟（70ms）：效率48%，但需精确调整

**协议6（选择性重传）：**
- 延迟变化几乎不影响效率（76-78%，波动仅2%）
- 各种延迟下都保持高性能
- 无需根据网络条件调整参数
- 证明具有优秀的延迟适应性

**延迟方差增加的影响：**

1. **协议5：**
   - 难以设置合适的超时值
   - 超时过短：大量误判超时
   - 超时过长：响应慢，效率低
   - 性能严重依赖网络稳定性

2. **协议6：**
   - 只重传真正丢失的帧
   - 即使有误判超时，影响也小
   - 自动适应延迟变化
   - 性能基本不受延迟方差影响

**实际网络场景：**

1. **无线网络：**
   - 延迟波动大（10-200ms）
   - P6效率保持77%，P5波动在30-50%
   - P6适合移动通信

2. **拥塞网络：**
   - RTT随拥塞变化
   - P6能自动适应，P5需动态调整超时
   - P6实现更简单

3. **多路径路由：**
   - 不同路径延迟差异大
   - P6容忍乱序，P5强制顺序
   - P6更适合现代互联网

**结论：**
- 延迟方差对Go-Back-N影响大，需要精确的超时调整
- 选择性重传对延迟变化不敏感，自适应能力强
- 现代网络延迟不稳定，应优先选择协议6
- 延迟方差是选择性重传优于Go-Back-N的重要原因之一

---

## 七、综合结论与建议

### 7.1 核心结论

1. **协议选择：**
   - 协议6（选择性重传）在所有测试条件下均显著优于协议5（Go-Back-N）
   - 效率提升30-143%，重传减少65-95%
   - 推荐现代网络应用优先选择协议6

2. **性能影响因素排序：**
   - 协议类型（P5 vs P6）：影响最大（+30~143%）
   - 丢包率：显著影响（每5%约降低8-10%效率）
   - 校验和错误率：明显影响（每5%约降低4-6%效率）
   - 超时间隔：P5敏感（波动4%），P6不敏感（波动2%）
   - 事件优先级：影响很小（差异<2%）

3. **参数配置建议：**
   - 协议5：超时40-80ms，适用于低丢包率稳定网络（<10%）
   - 协议6：超时50-100ms，适用于各种网络环境
   - 窗口大小：MAX_SEQ=7已足够，继续增大收益有限

4. **网络适应性：**
   - 协议6对网络条件变化不敏感，部署简单
   - 协议5需要根据网络特征精确调优
   - 延迟不稳定的网络强烈推荐协议6

### 7.2 实践应用建议

#### 7.2.1 协议选择决策树

```
网络类型判断：
├─ 局域网/光纤直连（丢包<1%，延迟稳定）
│  └─ 资源受限？
│     ├─ 是 → 协议5（简单高效）
│     └─ 否 → 协议6（最佳性能）
│
├─ 无线网络/移动通信（丢包5-15%，延迟波动）
│  └─ 协议6（必选）
│
├─ 广域网/互联网（丢包率不确定，延迟不稳定）
│  └─ 协议6（推荐）
│
└─ 卫星链路/长距离（高延迟，中等丢包）
   └─ 协议6（显著优势）
```

#### 7.2.2 参数配置表

| 网络环境 | 协议选择 | 超时间隔 | 窗口大小 | 预期效率 |
|---------|---------|---------|---------|---------|
| 局域网 | P5/P6 | 20-40ms | 7-15 | 70-93% |
| 企业网 | P6 | 40-60ms | 7-15 | 77-85% |
| 无线网 | P6 | 50-100ms | 7-15 | 76-78% |
| 移动网 | P6 | 80-150ms | 7-15 | 75-78% |
| 广域网 | P6 | 100-200ms | 7-15 | 76-78% |
| 卫星链路 | P6 | 500-1000ms | 15-31 | 70-75% |

#### 7.2.3 实现建议

**协议5实现要点：**
1. 简化接收方逻辑（只需1帧缓存）
2. 实现高效的累积确认
3. 动态超时调整机制
4. 适用于嵌入式、IoT设备

**协议6实现要点：**
1. 维护接收窗口（N帧缓存）
2. 独立管理每帧的定时器
3. 实现乱序接收和缓存
4. 位图优化确认机制
5. 适用于高性能网络应用

### 7.3 实验收获与体会

1. **理论与实践结合：**
   - 通过实验验证了教材中的理论分析
   - 直观理解了滑动窗口协议的工作机制
   - 深刻认识到协议设计的权衡取舍

2. **性能评估方法：**
   - 掌握了系统化的协议性能测试方法
   - 学会了参数敏感性分析
   - 理解了效率、吞吐量、重传率等性能指标

3. **工程实践能力：**
   - 熟悉了C语言系统编程
   - 掌握了进程间通信（管道）
   - 学会了大规模实验数据的收集和分析

4. **问题解决能力：**
   - 编译错误（多重定义）→ extern声明分离
   - 性能优化（时间推进）→ 智能跳跃
   - 数据提取（脚本错误）→ 输入清洗

### 7.4 不足与改进

**实验不足：**
1. 未实现真正的可变延迟队列（实验6简化）
2. 未测试更大的窗口大小（MAX_SEQ > 7）
3. 未进行多次重复实验求平均值
4. 未测试协议3和协议4

**改进方向：**
1. 实现完整的延迟队列机制
2. 测试窗口大小对性能的影响（7-127）
3. 统计分析和置信区间
4. 比较更多协议变体
5. 真实网络环境测试

### 7.5 未来展望

1. **协议改进：**
   - 选择性确认（SACK）优化
   - 前向纠错（FEC）结合
   - 拥塞控制集成

2. **性能优化：**
   - 自适应窗口大小
   - 动态超时估计（Jacobson算法）
   - 快速重传机制

3. **实际应用：**
   - TCP协议中的SACK
   - QUIC协议的可靠传输
   - 5G网络的RLC层

---

## 八、附录

### 附录A：实验数据汇总

完整的186条实验数据保存在`实验数据汇总.csv`文件中，包含：
- 实验1：22条记录
- 实验2：40条记录
- 实验3：3条记录
- 实验4：108条记录
- 实验5：2条记录
- 实验6：10条记录

数据可直接导入Excel/LibreOffice进行图表制作和深度分析。

### 附录B：关键代码修改

**1. 修复多重定义错误（common.h）**
```c
// 将定义改为extern声明
extern int protocol;
extern bigint timeout_interval;
extern int pkt_loss;
extern int garbled;
extern int debug_flags;
extern bigint tick;
```

**2. 时间推进优化（sim.c）**
```c
if (hanging[0] >= DELTA && hanging[1] >= DELTA) {
    tick = tick + DELTA * 10;  // 加速10倍
    // ...处理...
} else {
    tick = tick + DELTA;  // 正常速度
    // ...处理...
}
```

**3. 事件优先级修改（worker.c）**
```c
// 超时优先配置
case 5:
    if (check_timers() >= 0) return(timeout);
    if (nframes > 0) return((int)frametype());
    if (network_layer_status) return(network_layer_ready);
    return(NO_EVENT);
```

### 附录C：实验脚本

所有批量执行和数据提取脚本保存在实验目录：
- `run_all_experiments.sh`：执行实验1、2、4
- `run_exp6.sh`：执行实验6
- `extract_all_data.sh`：提取主要实验数据
- `extract_exp3_5.sh`：提取实验3、5数据
- `extract_exp6.sh`：提取实验6数据

### 附录D：参考资料

1. Andrew S. Tanenbaum, "Computer Networks, 3rd Edition"
2. RDT协议模拟器README文档
3. POSIX标准文档
4. TCP/IP协议相关RFC文档

---

## 实验总结

本次实验通过186个系统化的测试，全面评估了Go-Back-N和选择性重传两种滑动窗口协议的性能特征。实验结果清晰地表明，选择性重传协议在效率、稳定性和网络适应性方面均显著优于Go-Back-N协议。

通过实验，我们不仅验证了理论知识，还掌握了协议性能评估的方法论，为未来的网络协议设计和优化工作打下了坚实基础。实验中遇到的问题和解决方案也提供了宝贵的工程实践经验。

**实验完成日期：** 2025年12月28日  
**数据完整性：** ✅ 186条测试记录完整保存  
**实验可重复性：** ✅ 所有原始数据和脚本已备份
